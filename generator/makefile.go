package generator

import (
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// Makefile represents a builder for Makefile rules.
type Makefile struct {
	variables  []string
	includes   []string
	flags      []string
	libraries  []string
	libdirs    []string
	cleanItems []string
	rules      strings.Builder
	targets    []string // List of targets for the Makefile
}

// makefile creates a new Makefile instance.
func makefile() *Makefile {
	return &Makefile{}
}

// Name returns the name of the generated file ("Makefile").
func (m *Makefile) Name() string {
	return "Makefile"
}

// GenerateProjectName adds a PROJECT_NAME variable to the Makefile header.
func (m *Makefile) GenerateProjectName(name string) {
	m.variables = append(m.variables, "PROJECT_NAME := "+name)
}

// GenerateVersion adds a VERSION variable to the Makefile header.
func (m *Makefile) GenerateVersion(version string) {
	m.variables = append(m.variables, "VERSION ?= "+version)
}

// GenerateBuildDir adds a BUILD_DIR variable and a rule to create the build directory.
func (m *Makefile) GenerateBuildDir(name string) {
	m.variables = append(m.variables, "BUILD_DIR ?= "+name)
	m.addRule("", "$(BUILD_DIR)", nil, []string{"@mkdir -p $(@)"})
	m.addOptionalCleanItem("rm -rf $(BUILD_DIR)")
}

// AddInclude adds an include directory to the Makefile.
func (m *Makefile) AddIncludeDir(dir string) {
	if dir != "" {
		m.includes = append(m.includes, dir)
	}
}

func (m *Makefile) GenerateCPPStandard(standard int) {
	if standard != 0 {
		m.AddFlag("-std=c++" + strconv.Itoa(standard))
	}
}

// AddFlag adds a compiler flag to the Makefile.
func (m *Makefile) AddFlag(flag string) {
	if flag != "" {
		m.flags = append(m.flags, flag)
	}
}

// AddLibrary adds a library to the list of libraries to link against.
func (m *Makefile) AddLibrary(lib string) {
	if lib != "" {
		m.libraries = append(m.libraries, lib)
	}
}

// AddLibDir adds a directory to the list of library directories to search.
func (m *Makefile) AddLibDir(dir string) {
	if dir != "" {
		m.libdirs = append(m.libdirs, dir)
	}
}

// AddSource adds a source file to the Makefile.
func (m *Makefile) AddSource(source string) {
	if source != "" {
		objFile := strings.TrimSuffix(source, ".cpp") + ".o"
		objFilePath := "$(BUILD_DIR)/" + objFile
		basedir := filepath.Dir(objFilePath)
		m.addRule("", basedir, nil, []string{"@mkdir -p $(@)"})
		m.addRule("", objFilePath, []string{source, basedir}, []string{"$(CXX) $(CXXFLAGS) -c $< -o $@"})
	}
}

// GenerateFiles writes the generated Makefile rules to the specified output directory.
// It creates the directory if it does not exist.
func (m *Makefile) GenerateFiles(outDir string) error {
	if _, err := os.Stat(outDir); os.IsNotExist(err) {
		err = os.MkdirAll(outDir, 0755)
		if err != nil {
			return err
		}
	}

	file, err := os.OpenFile(outDir+"/Makefile", os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write Disclaimer
	_, err = file.WriteString(
		"\n# DO NOT EDIT THIS FILE MANUALLY\n" +
			"## This Makefile is generated using YABT(github.com/abhiroopdatta7/YABT)\n\n")
	if err != nil {
		return err
	}

	// Write Variables
	variables := strings.Join(m.variables, "\n")
	_, err = file.WriteString(variables + "\n")
	if err != nil {
		return err
	}

	// Write Includes
	for _, v := range m.includes {
		m.flags = append(m.flags, "-I"+v)
	}

	// Write Flags
	if len(m.flags) > 0 {
		flags := strings.Join(m.flags, " ")
		_, err = file.WriteString("CXXFLAGS += " + flags + "\n")
		if err != nil {
			return err
		}
	}

	// Write Libraries
	if len(m.libraries) > 0 {
		var libs string
		for _, lib := range m.libraries {
			libs += "-l" + lib + " "
		}
		_, err = file.WriteString("LIBS += " + libs + "\n")
		if err != nil {
			return err
		}
	}

	// Write Library Directories
	if len(m.libdirs) > 0 {
		var libdirs string
		for _, libdir := range m.libdirs {
			libdirs += "-L" + libdir + " "
		}
		_, err = file.WriteString("LDFLAGS += " + libdirs + "\n")
		if err != nil {
			return err
		}
	}

	// Write Clean Items
	if len(m.cleanItems) > 0 {
		m.addRule("clean", "clean", nil, m.cleanItems)
	}

	// Write Rules
	if m.rules.Len() > 0 {
		_, err = file.WriteString("\n" + m.rules.String())
		if err != nil {
			return err
		}
	}
	return nil
}

// PRIVATE METHODS

// addOptionalCleanItem appends an optional clean command to the clean section of the Makefile.
func (m *Makefile) addOptionalCleanItem(cmd string) {
	m.cleanItems = append(m.cleanItems, "- @"+cmd)
}

func (m *Makefile) addRule(phonyTarget string, target string, dependencies []string, cmds []string) {
	if target == "" {
		return // No target specified, skip adding the rule
	}

	// if target or phonyTarget is in targetlist, skip adding the rule
	for _, t := range m.targets {
		if t == target || t == phonyTarget {
			return
		}
	}
	m.targets = append(m.targets, target)
	if phonyTarget != "" {
		m.targets = append(m.targets, phonyTarget)
	}

	// Build the rule
	dependency := strings.Join(dependencies, " ")
	cmd := strings.Join(cmds, "\n\t")
	if phonyTarget != "" {
		m.rules.WriteString(".PHONY: " + phonyTarget + "\n")
	}
	m.rules.WriteString(target + ": " + dependency + "\n\t" + cmd + "\n\n")
}
